#include "grouping.hpp"
#include "partitioning.hpp"

#include <unordered_set>
#include <fstream>

// TODO: Pick UBFACTOR?
static const int UBFACTOR = 8;

static const std::string HYPERGRAPH_FILE_HEADER = "% Auto-generated by sfqplace";

// Type for hmetis input file to indicate a graph with weighted hyperedges
static const int HYPERGRAPH_TYPE_WEIGHTED_EDGES = 1;

PWayPartitioner::PWayPartitioner(Subgraph *subgraph, int groups) {
    this->subgraph = subgraph;
    this->desiredPartitionCount = groups;

    this->hmetisInputFilename = "hmetis_input_" 
                                + std::to_string(subgraph->getLogicLevel()) 
                                + ".graph";

    this->hewgts = nullptr;
    this->eind = nullptr;
    this->eptr = nullptr;
}

PWayPartitioner::~PWayPartitioner(void) {
    this->freeHMETISStructures();
}

void PWayPartitioner::freeHMETISStructures(void) {
    if (this->hewgts != nullptr) {
        delete this->hewgts;
    }

    if (this->eind != nullptr) {
        delete this->eind;
    }

    if (this->eptr != nullptr) {
        delete this->eptr;
    }
}

int PWayPartitioner::doPartition(void) {
    // Use default HMETIS options
    int hmetisOptions[9] = {0, };

    // Map from HMETIS vertex ID to it's connections (hyperedges)
    std::unordered_map<int, std::unordered_set<int>> hyperedges;
    std::vector<int> weights;
    int hyperedgeEndpointCount = 0;

    // First convert the subgraph into the hypergraph format for HMETIS

    // Reserve space in the weights array for at least as many edges as we have
    weights.reserve(this->subgraph->getEdges().size());

    this->nvtxs = this->subgraph->getVertices().size();

    // Create HMETIS-specific IDs starting from 0 for each vertex
    // Store a mapping in both directions between the different IDs
    int nextHID = 0;
    this->hmetisIdsMap.clear();
    this->sgraphIdsMap.clear();
    this->sgraphIdsMap.reserve(this->nvtxs);
    for (const auto &[sid, vertex] : this->subgraph->getVertices()) {
        this->hmetisIdsMap[sid] = nextHID;
        this->sgraphIdsMap[nextHID++] = sid;
    }

    // Populate the hyperedge map
    for (const SubgraphEdge *edge : this->subgraph->getEdges()) {
        // Get HMETIS-IDs for origin and target
        int originHID = hmetisIdsMap.at(edge->originNode);
        int targetHID = hmetisIdsMap.at(edge->targetNode);

        // Check if a hyperedge already exists from the origin node
        if (hyperedges.find(originHID) != hyperedges.end()) {
            hyperedges.at(originHID).insert(targetHID);
            // Added one element to existing hyperedge
            hyperedgeEndpointCount += 1;
        } else {
            std::unordered_set<int> newHyperedge;

            newHyperedge.insert(targetHID);
            hyperedges[originHID] = newHyperedge;

            // Added 2 elements: one for the origin and one for the target
            hyperedgeEndpointCount += 2;
        }

        // Store weight
        weights[originHID] = edge->weight;
    }
    
    // Set hyperedge count
    this->nhedges = hyperedges.size();

#if LINK_TO_HMETIS // HMETIS is compiled for i386
    // Allocate arrays for HMETIS
    this->freeHMETISStructures();
    this->hewgts = new int[this->nhedges];
    this->eptr = new int[this->nhedges + 1];
    this->eind = new int[hyperedgeEndpointCount];

    // Populate HMETIS data structures
    int eindIndex = 0;
    int eptrIndex = 0;
    for (const auto &[id, hedgeMembers] : hyperedges) {
        this->hewgts[id] = weights[id];

        // Store the starting location of this "eindIndex"th hyperedge
        this->eptr[eptrIndex++] = eindIndex;

        // Store all members of this hyperedge
        for (const int hedgeTarget : hedgeMembers) {
            this->eind[eindIndex++] = hedgeTarget;
        }
    }

    int *part;
    int partitionsCreated;

    HMETIS_PartKway(this->nvtxs, this->nhedges, NULL, this->eptr, this->eind, this->hewgts,
                    this->desiredPartitionCount, UBFACTOR, hmetisOptions, part, &partitionsCreated);

    return partitionsCreated;
#else 
    // We aren't linking to libhmetis, so run the standalone program as a system call
    // First write the hypergraph input to a file for it to read
    this->writeHMETISInput(hyperedges, weights);

    // Run HMETIS
    return this->invokeHMETIS();
#endif
}

void PWayPartitioner::writeHMETISInput(const std::unordered_map<int, std::unordered_set<int>> &hedges,
                                       const std::vector<int> &weights) {
    // TODO: write data to temporary file in the format HMETIS reads
    std::ofstream out(this->hmetisInputFilename);

    if (!out.is_open()) {
        std::cerr << "Failed to open hmetis input file: hmetis_input.graph" << std::endl;
        exit(1);
    } else {
        out << HYPERGRAPH_FILE_HEADER << std::endl;
        out << "% Hypergraph for subgraph of logic level: " << this->subgraph->getLogicLevel();
        out << std::endl;

        // First write number of hyperedges, vertices, and graph type
        out << this->nhedges << ' ' << this->nvtxs << ' ' << HYPERGRAPH_TYPE_WEIGHTED_EDGES;
        out << std::endl;

        // Now write each hyperedge
        for (const auto &[id, hedgeMembers] : hedges) {
            // Write weight
            out << weights[id];

            // Write origin
            out << ' ' << id;

            // Store all members of this hyperedge
            for (const int hedgeTarget : hedgeMembers) {
                out << ' ' << hedgeTarget;
            }

            out << std::endl;
        }

        out.close();
    }
}

int PWayPartitioner::invokeHMETIS(void) {
    // TODO: run khmetis via system call feeding it options and the temporary input file
    // then read the output file partition data and return number of partitions
    
    return -1;
}
